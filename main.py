import logging
import os
from aiogram import Bot, Dispatcher, executor, types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.contrib.fsm_storage.memory import MemoryStorage

# CONFIG
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHANNEL_LINK = "https://t.me/PROFESSORXZAMINHACKER"
DEVELOPER_ID = "@SIGMAXZAMIN"
BOT_NAME = "TEXT TO FILES GENERATOR BOT"

logging.basicConfig(level=logging.INFO)

bot = Bot(token=BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher(bot, storage=MemoryStorage())

# STATES
class FileState(StatesGroup):
    waiting_text = State()
    waiting_filename = State()
    waiting_format = State()

# KEYBOARDS
def main_kb():
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add("ğŸ“ Text â†’ File", "ğŸŒ Translate Text")
    kb.add("ğŸ“¢ Channel", "ğŸ‘¨â€ğŸ’» Developer")
    return kb

def format_kb():
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.add(
        types.InlineKeyboardButton("ğŸ“„ TXT", callback_data="txt"),
        types.InlineKeyboardButton("ğŸ PY", callback_data="py"),
        types.InlineKeyboardButton("ğŸŒ HTML", callback_data="html"),
        types.InlineKeyboardButton("ğŸ§© JSON", callback_data="json")
    )
    return kb

# START
@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    name = message.from_user.first_name
    await message.answer(
        f"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’€ <b>{BOT_NAME}</b> ğŸ’€
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ‘‘ Welcome <b>{name}</b>

This is not a normal generator.
This is your <b>code weapon</b> âš”ï¸

â¤ Text â†’ Real Files  
â¤ Multiple Languages  
â¤ Ready-to-use output  

â From idea to file â€” instantly â âš¡

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
""",
        reply_markup=main_kb()
    )

# TEXT TO FILE
@dp.message_handler(lambda m: m.text == "ğŸ“ Text â†’ File")
async def text_to_file(message: types.Message):
    await FileState.waiting_text.set()
    await message.answer(
        """
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœï¸ <b>SEND YOUR TEXT</b>

â¤ Paste code or plain text  
â¤ No limits, no filters  
â¤ Your content stays private  

â Words become files here â âš¡
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    )

@dp.message_handler(state=FileState.waiting_text)
async def get_text(message: types.Message, state: FSMContext):
    await state.update_data(text=message.text)
    await FileState.waiting_filename.set()
    await message.answer(
        """
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“› <b>SEND FILE NAME</b>

â¤ Without extension  
â¤ Example: <code>index</code>  

â Name it. Own it. â
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    )

@dp.message_handler(state=FileState.waiting_filename)
async def get_filename(message: types.Message, state: FSMContext):
    await state.update_data(filename=message.text)
    await FileState.waiting_format.set()
    await message.answer(
        "ğŸ§© <b>CHOOSE OUTPUT FORMAT</b>",
        reply_markup=format_kb()
    )

@dp.callback_query_handler(state=FileState.waiting_format)
async def make_file(call: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    text = data["text"]
    filename = data["filename"]
    ext = call.data

    content = f"""# Generated by {BOT_NAME}
# Developer: {DEVELOPER_ID}
# Channel: {CHANNEL_LINK}

{text}
"""

    file_path = f"{filename}.{ext}"
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)

    await call.message.answer_document(
        open(file_path, "rb"),
        caption="âœ… <b>Your file is ready!</b>"
    )

    await call.message.answer(
        f"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‰ <b>DONE!</b>

Your file is ready ğŸ“„  
Simple â€¢ Fast â€¢ Reliable  

Use it anywhere â€” no edits needed.

ğŸ‘¨â€ğŸ’» Developer: {DEVELOPER_ID}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    )

    os.remove(file_path)
    await state.finish()

# EXTRA BUTTONS
@dp.message_handler(lambda m: m.text == "ğŸ“¢ Channel")
async def channel(message: types.Message):
    await message.answer(CHANNEL_LINK)

@dp.message_handler(lambda m: m.text == "ğŸ‘¨â€ğŸ’» Developer")
async def dev(message: types.Message):
    await message.answer(DEVELOPER_ID)

# RUN
if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
